---
title: 行为型设计模式.md
date: 2021-11-23 22:43:16
tags:
categories:
- 设计模式
---

### 观察者模式

#### 定义

又称为发布订阅模式。在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）。

#### 作用

不同行为之间（观察者和被观察者）进行解耦，对扩展开放，对修改关闭。

#### 实现1

**一个p2p投资理财系统，用户注册成功之后，我们给用户发放投资体验金。**

使用普通的方法调用：用户注册Service，发放体验金Service，在Controller中依次调用这两个方法。

```java
public class UserController {
    private UserService userService;
    private PromotionService promotionService;

    public Long register(String telephone, String password) {
        // ...参数校验

        // 注册
        long userId = userService.register(telephone, password);
        // 发放投资体验金
        promotionService.issueNewUserExperienceCash(userId);
        return userId;
    }

}
```

注册接口做了两件事：注册和发放投资体验金，如果需求改动频繁，注册成功后改为发放优惠券，发短信提醒等等，这段代码就违背了开闭原则，后续如果需要在注册只会增加其他功能，比如：给用户发送新人红包，发送注册成功短信等。下面使用观察者模式进行重构。

#### 实现2

使用观察者模式实现。

- 定义一个观察者接口

```java
public interface RegObserver {
    void handleRegSuccess(long userId);
}
```

- 具体需要做哪些事定义为接口的实现类

```java
public class RegPromotionObserver implements RegObserver {
    private PromotionService promotionService;

    @Override
    public void handleRegSuccess(long userId) {
        // 发放投资体验金
        promotionService.issueNewUserExperienceCash(userId);
    }
}
```

```java
public class RegNoitificationObserver implements RegObserver {
    private NotificationService notificationService;

    @Override
    public void handleRegSuccess(long userId) {
        // 发送欢迎短信
        notificationService.sendInboxMessage(userId, "Welcome...");
    }
}
```

```java
public class UserController {
    private UserService userService;
    private List<RegObserver> regObservers = new ArrayList<>();

    // 一次设置好，之后不会再动态更改
    public void setRegObserves(List<RegObserver> observes) {
        regObservers.addAll(observes);
    }

    public Long register(String telephone, String password) {
        // ...参数校验

        // 注册
        long userId = userService.register(telephone, password);

        // 通知观察者
        for (RegObserver regObserver : regObservers) {
            regObserver.handleRegSuccess(userId);
        }

        return userId;
    }
}
```

使用这种方式实现，对于注册之后的行为，注册方法不需要去关注。

这种方式使用了同步阻塞的方式，依然有缺陷，观察者代码会被阻塞执行，观察者代码的执行结果会影响注册逻辑的成功执行。

#### 实现3

异步非阻塞方式实现。

- 线程池
  
  这种方式将线程池和异步执行逻辑耦合在注册代码中，提高了维护成本；并且如果需求在同步和异步之间来回切换，就需要频繁改动注册代码。
  
- Guava EventBus

  ```java
  public class UserController {
      private UserService userService = new UserService();
  
      private EventBus eventBus;
      private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;
  
      public UserController() {
          // this.eventBus = new EventBus(); 同步阻塞模式
          this.eventBus = new AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE));
      }
  
      // 一次设置好，之后不会再动态更改
      public void setRegObserves(List<Object> observes) {
          for (Object obj : observes) {
              eventBus.register(obj);
          }
      }
  
      public Long register(String telephone, String password) {
          // ...参数校验
  
          // 注册
          long userId = userService.register(telephone, password);
  
          // 通知观察者
          eventBus.post(userId);
  
          return userId;
      }
  }
  
  public class RegNoitificationObserver{
      private NotificationService notificationService = new NotificationService() {
          @Override
          public void sendInboxMessage(long userId, String message) {
              // ...
              System.out.println(userId + ", " + message);
          }
      };
  
      @Subscribe
      public void handleRegSuccess(Long userId) {
          notificationService.sendInboxMessage(userId, "Welcome...");
      }
  }
  
  public class RegPromotionObserver{
      private PromotionService promotionService = new PromotionService() {
          @Override
          public void issueNewUserExperienceCash(long userId) {
              System.out.println(userId + ", Promotion is done");
          }
      };
  
      @Subscribe
      public void handleRegSuccess(Long userId) {
          promotionService.issueNewUserExperienceCash(userId);
      }
      
      //    @Subscribe
  //    public void handleRegSuccess2(Integer userId) {
  //        System.out.println("hello pro");
  //    }
  }
  ```
  
  使用这种方式不需要定义Observer接口，只需要通过@Subscribe表明哪个方法可以接收被观察者发送的消息即可，如果注册之后不再需要发放体验金，去掉该注解即可。
  
  但需要注意，观察者的入参需要是eventBus.register(obj)中obj对象及父类的包装类。

#### 实现4

Spring也提供了针对观察者模式的扩展。

#### 实现5

通过消息队列实现。

这种方式更有利于观察者和被观察者的解耦，但是额外引入了中间件，增加了系统的复杂性；一般分布式系统中不同项目间的通信使用这种方式。

---

### 模板模式

#### 定义

模板模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

#### 作用

代码的复用和扩展。

#### 实现

通过抽象类中定义算法骨架，具体实现中对某些步骤进行实现。

模板方法定义为final，可以避免被子类重写；需要重写的方法定义为abstract，可以强迫子类去实现。

```java
public abstract class AbstarctClass {

    public final void templateMethod() {
        // ...
        
        method1();
        //...
        method2();
        //...
    }

    protected abstract void method2();

    protected abstract void method1();

}

public class ConcreteClass1 extends AbstarctClass {

    @Override
    protected void method2() {

    }

    @Override
    protected void method1() {

    }
}

public class ConcreteClass2 extends AbstarctClass {

    @Override
    protected void method2() {
        
    }

    @Override
    protected void method1() {

    }
}

public class Demo {

    public static void main(String[] args) {
        AbstarctClass demo = new ConcreteClass1();
        demo.templateMethod();
    }
}
```

#### JDK中的实现

##### 集合

在AbstractList中，addAll()方法提供了算法骨架，add()方法需要子类实现，虽然没有声明为abstract，但是如果子类不实现就直接抛出异常。

```java
public boolean addAll(int index, Collection<? extends E> c) {
    rangeCheckForAdd(index);
    boolean modified = false;
    for (E e : c) {
        add(index++, e);
        modified = true;
    }
    return modified;
}

public void add(int index, E element) {
    throw new UnsupportedOperationException();
}
```

##### 排序

模板模式提供了框架的扩展点，让框架使用者，在不修改框架源码的情况下，基于扩展点定制化框架的功能。Java 中的 Collections 类的 sort() 函数也利用了模板模式的这个扩展特性。

Collections.sort() 实现了对集合的排序。为了扩展性，它将其中“比较大小”这部分逻辑，委派给用户来实现。如果我们把比较大小这部分逻辑看作整个排序逻辑的其中一个步骤，那我们就可以把它看作模板模式。不过，从代码实现的角度来看，并不是模板模式的经典代码实现，而是基于 Callback 回调机制来实现的。

A 类（Demo）事先注册某个函数 F（Comparator的具体实现） 到 B 类（Collections），A 类在调用 B 类的 P 函数（sort）的时候，B 类反过来调用 A 类注册给它的 F 函数。回调也具有复用和扩展的功能。

```java
public static <T> void sort(List<T> list, Comparator<? super T> c) {
    list.sort(c);
}

// 使用
public class Demo {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 19, 89.0f));
        students.add(new Student("Peter", 20, 78.0f));
        students.add(new Student("Leo", 18, 99.0f));

        Collections.sort(students, new AgeAscComparator());
        print(students);

        System.out.println("-----------------------------------");

        Collections.sort(students, new NameAscComparator());
        print(students);

        System.out.println("-----------------------------------");

        Collections.sort(students, new ScoreDescComparator());
        print(students);
    }

    public static void print(List<Student> students) {
        for (Student s : students) {
            System.out.println(s.getName() + " " + s.getAge() + " " + s.getScore());
        }
    }

    public static class AgeAscComparator implements Comparator<Student> {
        @Override
        public int compare(Student o1, Student o2) {
            return o1.getAge() - o2.getAge();
        }
    }

    public static class NameAscComparator implements Comparator<Student> {
        @Override
        public int compare(Student o1, Student o2) {
            return o1.getName().compareTo(o2.getName());
        }
    }

    public static class ScoreDescComparator implements Comparator<Student> {
        @Override
        public int compare(Student o1, Student o2) {
            if (Math.abs(o1.getScore() - o2.getScore()) < 0.001) {
                return 0;
            } else if (o1.getScore() < o2.getScore()) {
                return 1;
            } else {
                return -1;
            }
        }
    }
}

```

##### HttpServlet

```java
public class HelloServlet extends HttpServlet {
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    this.doPost(req, resp);
  }
  
  @Override
  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    resp.getWriter().write("Hello World.");
  }
}
```

当我们在浏览器中输入网址（比如，http://127.0.0.1:8080/hello ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。

```java
public void service(ServletRequest req, ServletResponse res)
    throws ServletException, IOException
{
    HttpServletRequest  request;
    HttpServletResponse response;
    if (!(req instanceof HttpServletRequest &&
            res instanceof HttpServletResponse)) {
        throw new ServletException("non-HTTP request or response");
    }
    request = (HttpServletRequest) req;
    response = (HttpServletResponse) res;
    service(request, response);
}

protected void service(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException
{
    String method = req.getMethod();
    if (method.equals(METHOD_GET)) {
        long lastModified = getLastModified(req);
        if (lastModified == -1) {
            // servlet doesn't support if-modified-since, no reason
            // to go through further expensive logic
            doGet(req, resp);
        } else {
            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
            if (ifModifiedSince < lastModified) {
                // If the servlet mod time is later, call doGet()
                // Round down to the nearest second for a proper compare
                // A ifModifiedSince of -1 will always be less
                maybeSetLastModified(resp, lastModified);
                doGet(req, resp);
            } else {
                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            }
        }
    } else if (method.equals(METHOD_HEAD)) {
        long lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);
    } else if (method.equals(METHOD_POST)) {
        doPost(req, resp);
    } else if (method.equals(METHOD_PUT)) {
        doPut(req, resp);
    } else if (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);
    } else if (method.equals(METHOD_OPTIONS)) {
        doOptions(req,resp);
    } else if (method.equals(METHOD_TRACE)) {
        doTrace(req,resp);
    } else {
        String errMsg = lStrings.getString("http.method_not_implemented");
        Object[] errArgs = new Object[1];
        errArgs[0] = method;
        errMsg = MessageFormat.format(errMsg, errArgs);
        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
    }
}
```

从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。

#### 扩展

如果我们某个实现只用到其中的一个模板方法，也需要把所有抽象方法都实现一遍，怎么优化？

```java
public abstract AbstractClass {
    public final void templateMethod1() {
        // ...
        method1();
        //...
        method2();
        //...
    }
    
    public final void templateMethod() {
        // ...
        method3();
        // ...
        method4();
        //...
    }
    
    public abstract void method1();
    public abstract void method2();
    public abstract void method3();
    public abstract void method4();
}
```

第一种：如果某个实现只用到一个模板方法，说明这个类不应该设置这么多的抽象方法，应该拆分成更细粒度的两个类；

第二种：给不常用（不是每个子类都需要实现一遍）的抽象方法设置默认实现。

---

### 策略模式

#### 定义

定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端。

#### 作用

对策略的定义、创建和使用进行解耦。

#### 实现

##### 普通实现

```java
public static void main(String[] args) throws IOException {
    String type = "A";
    if ('A'.equals(type)) {
        // A逻辑
        
    } else if ('B'.equals(type)) {
        // B逻辑
        
    }
}
```

##### 策略的定义

包含一个策略接口和一组实现这个接口的策略类。

```java
public interface Strategy {
    void algoInterface();
}

public class ConcreteStrartegyA implements Strategy {
    @Override
    public void algoInterface() {
        //...具体算法
        System.out.println("this is A");
    }
}

public class ConcreteStrartegyB implements Strategy {
    @Override
    public void algoInterface() {
        //...具体算法
        System.out.println("this is B");
    }
}
```

##### 策略的创建

一般在使用的时候，会通过类型（type）来判断创建哪个策略来进行使用；为了封装创建逻辑，我们把根据type创建策略的逻辑抽出来放到工厂类中。

- 无状态策略

  如果策略对象可以被共享使用（单例），那么可以采用如下的工厂方法创建策略。

  ```java
  public class StrategyFactory {
  
      private static final Map<String, Strategy> strategies = new HashMap<>();
  
      static {
          strategies.put("A", new ConcreteStrartegyA());
          strategies.put("B", new ConcreteStrartegyB());
      }
  
      public static Strategy getStrategy(String type) {
          if (type == null || type.isEmpty()) {
              throw new IllegalArgumentException("type should not be empty.");
          }
          return strategies.get(type);
      }
  }
  ```
  
- 有状态策略

  如果策略是有状态的，我们希望每次都获取的是新创建的策略对象，那么采用如下方式。

  ```java
  public class StrategyFactory2 {
  
      public static Strategy getStrategy(String type) {
          if (type == null || type.isEmpty()) {
              throw new IllegalArgumentException("type should not be empty.");
          }
  
          if ("A".equals(type)) {
              return new ConcreteStrartegyA();
          } else if ("B".equals(type)) {
              return new ConcreteStrartegyB();
          }
          return null;
      }
  }
  ```

##### 策略的使用

根据传入的参数，运行时动态确定。

```java
public class StrategyDemo {

    public static void main(String[] args) {
        String type = args[0];
        Strategy strategy = StrategyFactory.getStrategy(type);
        strategy.algoInterface();
    }
}
```
---

### 职责链模式

#### 定义

将请求的发送和接收解耦，让多个对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。

多个处理器依次处理同一个请求，一个请求先经过A处理器处理，然后再把请求传递给B处理器，以此类推，形成一个链条。链条上的每个处理器处理各自的处理职责，所以叫做职责链模式。

#### 实现1

链表方式实现。

```java
public abstract class Handler {
    // 下一级处理器
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    // 结合模板模式
    public final void handle() {
        // 当前处理器处理请求
        boolean handled = doHandle();
        // 如果当前能处理，就不往下传递，如果还有下一处理器 并且 当前处理失败，交给下一处理器处理
        // 变体：如果想让所有处理器都处理一遍，修改此处的if条件即可
        if (successor != null && !handled) {
            successor.handle();
        }
    }

    // 处理结果为false，当前不能处理，继续交给下一级处理器；如果为true，直接返回结果
    protected abstract boolean doHandle();
}

public class HandlerA extends Handler {

    @Override
    protected boolean doHandle() {
        boolean handled = false;
        // ...当前处理器处理逻辑，如果当前处理成功，不需要下一级处理，返回true
        System.out.println("A处理失败，向下传递...");
        return handled;
    }
}

public class HandlerB extends Handler {

    @Override
    protected boolean doHandle() {
        boolean handled = false;
        // ...当前处理器处理逻辑，如果当前处理成功，不需要下一级处理，返回true
        System.out.println("B处理成功...");
        return handled;
    }
}

public class HandlerChain {
    private Handler head;
    private Handler tail;

    public void addHandler(Handler handler) {
        handler.setSuccessor(null);

        if (head == null) {
            head = handler;
            tail = handler;
            return;
        }

        tail.setSuccessor(handler);
        tail = handler;
    }

    public void handle() {
        if (head != null) {
            head.handle();
        }
    }
}

public class Demo {

    public static void main(String[] args) {
        HandlerChain chain = new HandlerChain();
        chain.addHandler(new HandlerA());
        chain.addHandler(new HandlerB());
        chain.handle();
    }
}
```

#### 实现2

数组方式实现。

```java
public interface IHandler {
    boolean handle();
}

public class HandlerA implements IHandler {
    @Override
    public boolean handle() {
        boolean handled = false;
        // ...当前处理器处理逻辑，如果当前处理成功，不需要下一级处理，返回true
        System.out.println("A处理失败，向下传递...");
        return handled;
    }
}

public class HandlerB implements IHandler {
    @Override
    public boolean handle() {
        boolean handled = false;
        // ...当前处理器处理逻辑，如果当前处理成功，不需要下一级处理，返回true
        System.out.println("B处理失败，向下传递...");
        return handled;
    }
}

public class HandlerChain {
    private List<IHandler> handlers = new ArrayList<>();

    public void addHandler(IHandler handler) {
        handlers.add(handler);
    }

    public void handle() {
        for (IHandler handler : handlers) {
            // 当前可以成功处理，直接返回
            if (handler.handle()) {
                break;
            }
        }
    }
}

public class Demo {

    public static void main(String[] args) {
        HandlerChain chain = new HandlerChain();
        chain.addHandler(new HandlerA());
        chain.addHandler(new HandlerB());
        chain.handle();
    }
}
```

#### 示例

敏感词过滤：对一段文本进行判断，如果里面涉及到敏感词，就禁止展示。

```java
public interface SensitiveWorldFilter {
    /**
     * 敏感词过滤，如果当前文本含有敏感词，返回true
     * @param text
     * @return
     */
    boolean doFilter(String text);
}

public class PoliticalWordFilter implements SensitiveWorldFilter {
    @Override
    public boolean doFilter(String text) {
        if (text.contains("国家") || text.contains("党")) {
            System.out.println("当前文本敏感，为防止查水表，不予通过");
            return true;
        }
        return false;
    }
}

public class SexyWordFilter implements SensitiveWorldFilter {

    @Override
    public boolean doFilter(String text) {
        if (text.contains("性感")) {
            System.out.println("当前文本涉黄！");
            return true;
        }
        return false;
    }
}

public class SensitiveWorldFilterChain {
    private List<SensitiveWorldFilter> filters = new ArrayList<>();

    public void addFilter(SensitiveWorldFilter filter) {
        filters.add(filter);
    }

    public boolean filter(String text) {
        for (SensitiveWorldFilter filter : filters) {
            if (filter.doFilter(text)) {
                return true;
            }
        }
        return false;
    }

}

public class Demo {

    public static void main(String[] args) {
        // 文本
        String text = "性感荷官，在线发牌";
        String text2 = "好好学习，天天向上";
        // 敏感词过滤器
        SensitiveWorldFilterChain chain = new SensitiveWorldFilterChain();
        chain.addFilter(new SexyWordFilter());
        chain.addFilter(new PoliticalWordFilter());
        boolean illeagl = chain.filter(text);
//        boolean illeagl = chain.filter(text2);
        if (illeagl) {
            System.out.println("当前文本不合法！");
        } else {
            System.out.println("当前文本合法");
        }
    }
}
```

#### 框架源码

**Spring的HandlerInterceptor**

日常使用的样子

```java
public class LogInterceptor implements HandlerInterceptor {

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    System.out.println("拦截客户端发送来的请求.");
    return true; // 继续后续的处理
  }

  @Override
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    System.out.println("拦截发送给客户端的响应.");
  }

  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    System.out.println("这里总是被执行.");
  }
}
```

![image-20201125114846433](https://tva1.sinaimg.cn/large/0081Kckwly1gl19xi5u0lj322a0n6n5b.jpg)

Spring Interceptor 底层是基于职责链模式实现的。其中，HandlerExecutionChain 类是职责链模式中的处理器链。

https://www.jianshu.com/p/8a20c547e245

关键代码如下：

在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = "GET".equals(method);
            if (isGet || "HEAD".equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                    return;
                }
            }
			
            // 请求处理
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            // 响应处理
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException("Handler dispatch failed", err);
        }
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                               new NestedServletException("Handler processing failed", err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                // 总是执行
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
```

HandlerExecutionChain的关键代码

```java
public class HandlerExecutionChain {
 private final Object handler;
 private HandlerInterceptor[] interceptors;
 
 public void addInterceptor(HandlerInterceptor interceptor) {
  initInterceptorList().add(interceptor);
 }

 boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
  HandlerInterceptor[] interceptors = getInterceptors();
  if (!ObjectUtils.isEmpty(interceptors)) {
   for (int i = 0; i < interceptors.length; i++) {
    HandlerInterceptor interceptor = interceptors[i];
    if (!interceptor.preHandle(request, response, this.handler)) {
     triggerAfterCompletion(request, response, null);
     return false;
    }
   }
  }
  return true;
 }

 void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception {
  HandlerInterceptor[] interceptors = getInterceptors();
  if (!ObjectUtils.isEmpty(interceptors)) {
   for (int i = interceptors.length - 1; i >= 0; i--) {
    HandlerInterceptor interceptor = interceptors[i];
    interceptor.postHandle(request, response, this.handler, mv);
   }
  }
 }

 void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)
   throws Exception {
  HandlerInterceptor[] interceptors = getInterceptors();
  if (!ObjectUtils.isEmpty(interceptors)) {
   for (int i = this.interceptorIndex; i >= 0; i--) {
    HandlerInterceptor interceptor = interceptors[i];
    try {
     interceptor.afterCompletion(request, response, this.handler, ex);
    } catch (Throwable ex2) {
     logger.error("HandlerInterceptor.afterCompletion threw exception", ex2);
    }
   }
  }
 }
}
```



---

### 状态模式

##### 定义

##### 有限状态机

状态机有三个组成部分：状态、事件、动作。其中，事件也被称为转移条件。事件触发状态的转移及动作的执行。不过动作不是必须的，也可能只是转变状态，不执行任何动作。

#### 示例

**超级马里奥游戏**：

马里奥有多种形态，刚出生是小马里奥（Small Mario），可以进化成超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。	

马里奥遇到不同的事件可以进行形态转变，并进行积分的增减。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk55y3hl4qj31310u0tj5.jpg" alt="image-20201028171249300"  />

#### 代码实现

##### 方式1

**分支逻辑法**

定义一个状态枚举类，一个状态机类，状态机类中提供4个方法，分别是：吃了蘑菇，获得斗篷，获得火焰，遇到怪物。

```java
// 定义状态
public enum State {

    SMALL(0),
    SUPER(1),
    FIRE(2),
    CAPE(3),
    ;

    private int value;

    private State(int value) {
        this.value = value;
    }

    public int getValue() {
        return this.value;
    }
}
```

```java
// 状态机
public class MarioStateMachine {
    private int score;
    private State currentState;

    public MarioStateMachine() {
        this.score = 0;
        this.currentState = State.SMALL;
    }

    public void obtainMushRoom() {
        if (currentState.equals(State.SMALL)) {
            this.score += 100;
            this.currentState = State.SUPER;
        }
    }

    public void obtainCape() {
        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER)) {
            this.score += 200;
            this.currentState = State.CAPE;
        }

    }

    public void obtainFireFlower() {
        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER)) {
            this.score += 300;
            this.currentState = State.FIRE;
        }
    }

    public void meetMonster() {
        if (currentState.equals(State.SUPER)) {
            this.score -= 100;
            this.currentState = State.SMALL;
            return;
        }

        if (currentState.equals(State.CAPE)) {
            this.score -= 200;
            this.currentState = State.SMALL;
            return;
        }

        if (currentState.equals(State.FIRE)) {
            this.score -= 300;
            this.currentState = State.SMALL;
            return;
        }
    }

    public int getScore() {
        return this.score;
    }

    public State getCurrentState() {
        return this.currentState;
    }
}

public class ApplicationDemo {
    public static void main(String[] args) {
        // 游戏开始
        MarioStateMachine mario = new MarioStateMachine();
        // 吃到蘑菇
        mario.obtainMushRoom();
        int score = mario.getScore();
        State state = mario.getCurrentState();
        System.out.println("mario score：" + score + "; state: " + state);
    }
}
```

对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 if-else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug。

##### 方式2

**查表法**

使用二维数组表示状态和事件，如下表，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件后，转移到的新状态及执行的动作。

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk56dpaaawj31360don25.jpg" alt="image-20201028172751310"  />

定义一个事件类，事件类和State状态类可以组合成为上述的表格。

```java
// 定义状态
public enum State {

    SMALL(0),
    SUPER(1),
    FIRE(2),
    CAPE(3),
    ;

    private int value;

    private State(int value) {
        this.value = value;
    }

    public int getValue() {
        return this.value;
    }
}

public enum Event {

    GOT_MUSHROOM(0),
    GOT_CAPE(1),
    GOT_FIRE(2),
    MET_MONSTER(3),
    ;

    private int value;

    private Event(int value) {
        this.value = value;
    }

    public int getValue() {
        return this.value;
    }
}
```

定义状态机，横坐标为State的value，纵坐标为Event的value。

```java
public class MarioStateMachine {
    private int score;
    private State currentState;

    // 状态值
    private static final State[][] transitionTable = {
            {State.SUPER, State.CAPE, State.FIRE, State.SMALL},
            {State.SUPER, State.CAPE, State.FIRE, State.SMALL},
            {State.CAPE, State.CAPE, State.CAPE, State.SMALL},
            {State.FIRE, State.FIRE, State.FIRE, State.SMALL}
    };

    // 执行动作
    private static final int[][] actionTable = {
            {+100, +200, +300, +0},
            {+0, +200, +300, -100},
            {+0, +0, +0, -200},
            {+0, +0, +0, -300}
    };

    public MarioStateMachine() {
        this.score = 0;
        this.currentState = State.SMALL;
    }

    public void obtainMushRoom() {
        executeEvent(Event.GOT_MUSHROOM);
    }

    public void obtainCape() {
        executeEvent(Event.GOT_CAPE);
    }

    public void obtainFireFlow() {
        executeEvent(Event.GOT_FIRE);
    }

    public void meetMonster() {
        executeEvent(Event.MET_MONSTER);
    }

    private void executeEvent(Event event) {
        int stateValue = this.currentState.getValue();
        int eventValue = event.getValue();
        this.currentState = transitionTable[stateValue][eventValue];
        this.score += actionTable[stateValue][eventValue];
    }

    public int getScore() {
        return score;
    }

    public State getCurrentState() {
        return currentState;
    }
}
```

相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。

**查表法局限性**：

这个例子中，状态经过事件后，执行的动作只是得分的加减，如果动作比较复杂，例如，数据库入库，发送邮件，调用不同接口等等，就没法用简单的二维数组来表示了。

##### 方式3

**状态模式**

状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。

定义一个状态接口，接口就是状态，接口中的每个方法就是一种事件。

```java
public interface IMario {
    State getName();

    void obtainMushRoom(MarioStateMachine stateMachine);

    void obtainCape(MarioStateMachine stateMachine);

    void obtainFireFlow(MarioStateMachine stateMachine);

    void meetMonster(MarioStateMachine stateMachine);
}
```

每个状态接口的实现类就是具体的状态类（小马里奥类、超级马里奥类等）。

因为状态类中不包含任何成员变量，所以我们考虑把状态类设计成单例的。

```java
public class SmallMario implements IMario {
    private static final SmallMario instance = new SmallMario();
    private SmallMario() {}
    public static SmallMario getInstance() {
        return instance;
    }

    @Override
    public State getName() {
        return State.SMALL;
    }

    @Override
    public void obtainMushRoom(MarioStateMachine stateMachine) {
        stateMachine.setCurrentState(SuperMario.getInstance());
        stateMachine.setScore(stateMachine.getScore() + 100);
    }

    @Override
    public void obtainCape(MarioStateMachine stateMachine) {
        // ...
    }

    @Override
    public void obtainFireFlow(MarioStateMachine stateMachine) {

    }

    @Override
    public void meetMonster(MarioStateMachine stateMachine) {

    }
}

public class SuperMario implements IMario {
    private static final SuperMario instance = new SuperMario();
    private SuperMario() {}

    public static SuperMario getInstance() {
        return instance;
    }


    @Override
    public State getName() {
        return State.SUPER;
    }

    @Override
    public void obtainMushRoom(MarioStateMachine stateMachine) {
        // ...
    }

    @Override
    public void obtainCape(MarioStateMachine stateMachine) {
        // ...
    }

    @Override
    public void obtainFireFlow(MarioStateMachine stateMachine) {
        // ...
    }

    @Override
    public void meetMonster(MarioStateMachine stateMachine) {
        //...
    }
}
```

状态机

```java
public class MarioStateMachine {
    private int score;
    // 用接口表示状态
    private IMario currentState;

    public MarioStateMachine() {
        this.score = 0;
        this.currentState = SmallMario.getInstance();
    }

    public void setCurrentState(IMario currentState) {
        this.currentState = currentState;
    }

    public void obtainMushRoom() {
        this.currentState.obtainMushRoom(this);
    }

    public void obtainCape() {
        this.currentState.obtainCape(this);
    }

    public void obtainFireFlow() {
        this.currentState.obtainFireFlow(this);
    }

    public void meetMonster() {
        this.currentState.meetMonster(this);
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public IMario getCurrentState() {
        return currentState;
    }
}
```

使用方式

```java
public class ApplicationDemo {

    public static void main(String[] args) {
        MarioStateMachine mario = new MarioStateMachine();
        mario.obtainMushRoom();
        int score = mario.getScore();
        State state = mario.getCurrentState().getName();
        System.out.println("mario score：" + score + "; state: " + state);
    }
}
```

状态模式中，每个具体的状态类只需要关心自己遇到不同事件后流转到的下一个状态以及得分值的增减。

实际上，像游戏这种比较复杂的状态机，包含的状态比较多，优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。

---


### 迭代器模式

#### 定义

迭代器模式又叫游标模式，是用来遍历容器的；

一个完整的迭代器模式一般会涉及**容器**和**容器迭代器**两部分。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwh9i7svhpj312s0isgms.jpg" alt="image-20201028202346968"  />

假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我们从零开始开发。

#### 代码实现

##### 简单版

```java
public interface Iterator<E> {
    boolean hasNext();
    void next();
    E currentItem();
}

public class ArrayIterator<E> implements Iterator {
    // 游标
    private int curstor;
    private ArrayList<E> arrayList;

    public ArrayIterator(ArrayList<E> arrayList) {
        this.curstor = 0;
        this.arrayList = arrayList;
    }

    @Override
    public boolean hasNext() {
        return curstor != arrayList.size();
    }

    @Override
    public void next() {
        curstor++;
    }

    @Override
    public E currentItem() {
        if (curstor >= arrayList.size()) {
            throw new NoSuchElementException();
        }
        return arrayList.get(curstor);
    }
}

public class Demo {
    public static void main(String[] args) {
        ArrayList<String> name = new ArrayList<String>();
        name.add("张三");
        name.add("李四");
        name.add("王五");
        Iterator<String> iterator = new ArrayIterator<String>(name);
        while (iterator.hasNext()) {
            System.out.println(iterator.currentItem());
            iterator.next();
        }
    }
}
```

##### 优化

在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。为了封装迭代器的创建细节，我们可以在容器中定义iterator()方法创建迭代器；为实现基于接口编程，我们在List接口中定义这个方法。

```java
public interface List<E> {
  Iterator iterator();
  //...省略其他接口函数...
}

public class ArrayList<E> implements List<E> {
  //...
  public Iterator iterator() {
    return new ArrayIterator(this);
  }
  //...省略其他代码
}

public class Demo {
  public static void main(String[] args) {
    List<String> names = new ArrayList<>();
    names.add("aa");
    names.add("bb");
    names.add("cc");
    
    Iterator<String> iterator = names.iterator();
    while (iterator.hasNext()) {
      System.out.println(iterator.currentItem());
      iterator.next();
    }
  }
}
```

迭代器的实现思路总结：迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过 iterator() 方法来创建迭代器。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwh9io7x0ij315k0o0gnc.jpg" alt="image-20201117205945886"  />

#### 迭代器模式的优势

```java
List<String> names = new ArrayList<>();
names.add("xzg");
names.add("wang");
names.add("zheng");

// 第一种遍历方式：for循环
for (int i = 0; i < names.size(); i++) {
  System.out.print(names.get(i) + ",");
}

// 第二种遍历方式：foreach循环
for (String name : names) {
  System.out.print(name + ",")
}

// 第三种遍历方式：迭代器遍历
Iterator<String> iterator = names.iterator();
while (iterator.hasNext()) {
  System.out.print(iterator.next() + ",");//Java中的迭代器接口，next()既移动游标又返回数据
}
```

对遍历方式比较简单的线性数据结构，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性；

将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响；

容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。

#### 遍历的同时增删元素

**删除元素**

```java
public class RemoveDemo {

    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<>();
        names.add("a");
        names.add("b");
        names.add("c");
        names.add("d");

        Iterator<String> iterator = new ArrayIterator<String>(names);

        // 游标指向b时，移除a
        iterator.next();
        names.remove("a");
    }
}
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl1gk4i1d1j30pi0mw0ux.jpg" alt="image-20201125153805528"  />

在遍历过程删除元素，结果是不可预期的，有时候有问题，有时候没问题，要视删除元素的位置而定。

**增加元素**

```java
public class AddDemo {

    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<>();
        names.add("a");
        names.add("b");
        names.add("c");
        names.add("d");

        Iterator<String> iterator = new ArrayIterator<String>(names);

        // 游标指向b时，将x插入下标为0的位置
        iterator.next();
        names.add(0, "x");
      
}
```

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gl1gwvvbw6j30pg0jw40l.jpg" alt="image-20201125155021826"  />

跟删除情况类似，如果我们在游标的后面添加元素，就不会存在任何问题。所以，在遍历的同时添加集合元素也是一种不可预期行为。

**如何应对遍历时改变集合导致的不可预期行为**

迭代器要在遍历的元素的时候判断集合是否有增删改数据，如果有就报错。

#### JDK ArrayList中的迭代器

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable 
{
	public Iterator<E> iterator() {
    	return new Itr();
	}

    /**
     * An optimized version of AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }    
}
```

---

### 访问者模式

#### 寻源

假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。

##### 实现1

ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。

```java
public abstract class ResourceFile {
  protected String filePath;

  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }

  public abstract void extract2txt();
}

public class PPTFile extends ResourceFile {
  public PPTFile(String filePath) {
    super(filePath);
  }

  @Override
  public void extract2txt() {
    //...省略一大坨从PPT中抽取文本的代码...
    //...将抽取出来的文本保存在跟filePath同名的.txt文件中...
    System.out.println("Extract PPT.");
  }
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public void extract2txt() {
    //...
    System.out.println("Extract PDF.");
  }
}

public class WordFile extends ResourceFile {
  public WordFile(String filePath) {
    super(filePath);
  }

  @Override
  public void extract2txt() {
    //...
    System.out.println("Extract WORD.");
  }
}

// 运行结果是：
// Extract PDF.
// Extract WORD.
// Extract PPT.
public class ToolApplication {
  public static void main(String[] args) {
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.extract2txt();
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：

违背开闭原则，添加一个新的功能，所有类的代码都要修改；

虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；

把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的职责不够单一，变成了大杂烩。

**把业务操作和具体数据解耦，设计成独立的类。**

##### 实现2

```java
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }
  //...
}
//...PPTFile、WordFile代码省略...
public class Extractor {
  public void extract2txt(PPTFile pptFile) {
    //...
    System.out.println("Extract PPT.");
  }

  public void extract2txt(PdfFile pdfFile) {
    //...
    System.out.println("Extract PDF.");
  }

  public void extract2txt(WordFile wordFile) {
    //...
    System.out.println("Extract WORD.");
  }
}

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      extractor.extract2txt(resourceFile);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

上面的代码用到了方法重载，但是实际上是没法编译通过的，因为重载是静态绑定，我们传入ResourceFile类型的变量，但是找不到对应变量类型的方法。

##### 实现3

```java
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  abstract public void accept(Extractor extractor);
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public void accept(Extractor extractor) {
    extractor.extract2txt(this);
  }

  //...
}

//...PPTFile、WordFile跟PdfFile类似，这里就省略了...
//...Extractor代码不变...

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(extractor);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 Extractor 类的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：

##### 实现4

```java
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  abstract public void accept(Extractor extractor);
  abstract public void accept(Compressor compressor);
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public void accept(Extractor extractor) {
    extractor.extract2txt(this);
  }

  @Override
  public void accept(Compressor compressor) {
    compressor.compress(this);
  }

  //...
}

//...PPTFile、WordFile跟PdfFile类似，这里就省略了...
//...Extractor代码不变

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(extractor);
    }

    Compressor compressor = new Compressor();
    for(ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(compressor);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。

针对这个问题，我们抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了。

##### 实现5

```java
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  abstract public void accept(Visitor vistor);
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public void accept(Visitor visitor) {
    visitor.visit(this);
  }

  //...
}
//...PPTFile、WordFile跟PdfFile类似，这里就省略了...

public interface Visitor {
  void visit(PdfFile pdfFile);
  void visit(PPTFile pdfFile);
  void visit(WordFile pdfFile);
}

public class Extractor implements Visitor {
  @Override
  public void visit(PPTFile pptFile) {
    //...
    System.out.println("Extract PPT.");
  }

  @Override
  public void visit(PdfFile pdfFile) {
    //...
    System.out.println("Extract PDF.");
  }

  @Override
  public void visit(WordFile wordFile) {
    //...
    System.out.println("Extract WORD.");
  }
}

public class Compressor implements Visitor {
  @Override
  public void visit(PPTFile pptFile) {
    //...
    System.out.println("Compress PPT.");
  }

  @Override
  public void visit(PdfFile pdfFile) {
    //...
    System.out.println("Compress PDF.");
  }

  @Override
  public void visit(WordFile wordFile) {
    //...
    System.out.println("Compress WORD.");
  }

}

public class ToolApplication {
  public static void main(String[] args) {
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
      
    Extractor extractor = new Extractor();
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(extractor);
    }

    Compressor compressor = new Compressor();
    for(ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(compressor);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

#### 回首

##### 定义

允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。

![image-20201125174436993](https://tva1.sinaimg.cn/large/0081Kckwly1gl1k7t8oj9j31xq0u07i1.jpg)

##### 应用场景

访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。

#### 替代方式

我们还可以利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。

```java
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  public abstract ResourceFileType getType();
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public ResourceFileType getType() {
    return ResourceFileType.PDF;
  }

  //...
}

//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...

public interface Extractor {
  void extract2txt(ResourceFile resourceFile);
}

public class PdfExtractor implements Extractor {
  @Override
  public void extract2txt(ResourceFile resourceFile) {
    //...
  }
}

//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...

public class ExtractorFactory {
  private static final Map<ResourceFileType, Extractor> extractors = new HashMap<>();
  static {
    extractors.put(ResourceFileType.PDF, new PdfExtractor());
    extractors.put(ResourceFileType.PPT, new PPTExtractor());
    extractors.put(ResourceFileType.WORD, new WordExtractor());
  }

  public static Extractor getExtractor(ResourceFileType type) {
    return extractors.get(type);
  }
}

public class ToolApplication {
  public static void main(String[] args) {
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());
      extractor.extract2txt(resourceFile);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。

相反，如果工具提供非常多的功能，比如有十几个，更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。



### 参考

[设计模式之美-王争](https://time.geekbang.org/column/intro/100039001)